#!/usr/bin/env tsx

/**
 * https://inf-ege.sdamgia.ru/problem?id=33771
 * Тип 26 № 33771
 * Предприятие производит оптовую закупку некоторых изделий A и B, на которую выделена определённая сумма денег. У поставщика есть в наличии партии этих изделий различных модификаций по различной цене. На выделенные деньги необходимо приобрести как можно больше изделий B независимо от модификации. Если у поставщика закончатся изделия B, то на оставшиеся деньги необходимо приобрести как можно больше изделий A. Известны выделенная для закупки сумма, а также количество и цена различных модификаций данных изделий у поставщика. Необходимо определить, сколько будет закуплено изделий A и какая сумма останется неиспользованной.
 * Первая строка входного файла содержит два целых числа: N  — общее количество партий изделий у поставщика и M  — сумма выделенных на закупку денег (в рублях). Каждая из следующих N строк описывает одну партию и содержит два целых числа (цена одного изделия в рублях и количество изделий в партии) и один символ (латинская буква A или B), определяющий тип изделия. Все данные в строках входного файла отделены одним пробелом.
 * В ответе запишите два целых числа: сначала количество закупленных изделий типа A, затем оставшуюся неиспользованной сумму денег.
 * Пример входного файла:
 *   4 1000
 *   30 8 A
 *   50 12 B
 *   40 14 A
 *   20 10 B
 * В данном случае сначала нужно купить изделия B: 10 изделий по 20 рублей и 12 изделий по 50 рублей. На это будет потрачено 800 рублей. На оставшиеся 200 рублей можно купить 6 изделий A по 30 рублей. Таким образом, всего будет куплено 6 изделий A и останется 20 рублей. В ответе надо записать числа 6 и 20.
 */

import { dataRaw } from './task-1.data';

const data = dataRaw.split('\n').filter(Boolean);
let amount = data.shift()?.split(' ').map(Number).pop() ?? 0;
const items = data
	.map(item => item.split(' '))
	.map(([cost, count, type]) => [Number(cost), Number(count), type])
	.sort(([_cost, _count, type]) => (type === 'B' ? -1 : 1))
	.sort(([costPrev, , typePrev], [costNext, , typeNext]) =>
		(typePrev === 'B' && typeNext === 'B' && costPrev < costNext) ||
		(typePrev === 'A' && typeNext === 'A' && costPrev < costNext) ||
		(typePrev === 'B' && typeNext === 'A')
			? -1
			: 1,
	)
	.map(([cost, count, type]) => Array(count).fill([cost, type]))
	.flat();

const countA_before = items.filter(([, type]) => type === 'A').length;

while (amount > 0) {
	const [cost] = items.shift() ?? [];
	if (cost === undefined || amount < cost) {
		break;
	}
	amount -= cost;
}

const countA_after = items.filter(([, type]) => type === 'A').length;
const countA = countA_before - countA_after;

console.log({ amount, countA });

export default {};
