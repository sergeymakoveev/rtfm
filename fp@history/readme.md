# Fp: History

## Немного истории

1930 — проблема разрешения (Entscheidungsproblem), Давид Гильберт  
1936 — теория машины Тьюринга, математическая модель вычислений Алана Тьюринга  
1936 — лямбда-исчисление, универсальная модель вычислений Алонзо Чёрча (функциональный язык программирования, реализованный в виде алгебры, математически, пращур всех Фп-языков)  
1940e — теория категорий

**Модель вычислителя Тьюринга** - умозрительная абстракция.  
**Лямбда-исчисление** - раздел математической логики.

1954 — Fortran, Джон Бэкус  
1958 — Lisp, Джон Маккарти и Пол Грэм (FP)  
1970 — Pascal, Николас Вирт  
1971 — SmallTalk, Алан Кей (OOP)  
1971 — C, Деннис Ритчи  
1973 — ML, Робин Милнер (теория типов Милнера, потомки OCaml, F#, RisenML)  
1975 — Scheme, Гай Стил и Джеральд Сассман (FP)  
1987 — Haskell (FP)  
1983 — С++, Бьерн Страуструп (OOP)  
1991 — Python, Гвидо ван Россум (OOP, +FP)  
1995 — Java, Джеймс Гослинг (OOP, +FP)  
1995 — JavaScript (ECMAScript), Брэндон Айх (OOP, +FP)  
2003 — Scala, Мартин Одерски (FP, OOP)

Источники:  
* [Computer Languages History](https://www.levenez.com/lang/lang.pdf)  
* [Краткая, неполная, и в основном неверная история языков программирования](https://habr.com/ru/post/165093/)  
* [Краткая и на 146% точная история языков программирования](https://habr.com/ru/post/481822/)

Бесспорно что ООп в настоящее время значительно популярнее Фп.  
Почему?  
Математический базис/прототип высокоуровневого Фп-языка существовал уже в 1936г, в 1958 он воплотился в языке Lisp.  
Первый язык с ООп - SmallTalk, 1971.  
Между Lisp и SmallTalk лежит более 10 лет.  
Почему не стал популярен?

Наверняка причина кроется в сложности абстракций, которыми оперируют языки Фп.  
Гораздо нагляднее представить предметную область и бизнес-процессы в виде объектов, которые произвольно взаимодействуют друг с другом, нежели в виде композиции функций, которые обрабатывают потоки данных.

Современные высокоуровневые языки чаще всего являются мультипарадигменными - можно использовать как ООП, так и ФП, так и их сочетание.  
Конечно же есть и исключения - Haskel, Elm, Erlang, чаще Фп-языки отказываются от возможностей ООп, чем обратно.  
И наоборот, в языках ООп, стараются реализовать возможности для более удобного использования функциональных практик (lambda в Java, Promise в JavaScript)

## ООП и ФП

ООП: инкапсуляция, полиморфизм и наследование  
FP: алгебраические типы данных и функции высших порядков

OOП:
- предметная область представляется в виде объектов произвольной структуры
- для реализации бизнес-логики объекты произвольно взаимодействуют друг с другом
- много свободы - легко писать плохой код
- SOLID являются декларативными соглашениями для разумных ограничений этой свободы
- дизайн-паттерны для декларации популярных архитектурных решений на уровне соглашений

FP:
- предметная область и бизнес-логика выражаются в виде алгебраических типов данных и функций, отвечающих за композицию этих данных
- поставлены жесткие рамки - хороший код писать легче, чем плохой
- алгебраические структуры и алгебраические типы данных (как унифицированные, так и пользовательские)
  четко декларируют их использование на уровне типов и кода 

Всем будет понятно как обработать данные, если речь идет о массиве или промисе, т.к. "у них стандартное, всем известное api" (если говорить иначе мы знаем алгебраические операции или алгебру, реализованную для этих алгебраических типов данных).  
Менее понятная ситуация если речь идет о стеке, очереди, потоке, дереве, графе, векторе, матрице - на уровне негласных соглашений (дизайн-паттернов) мы представляем как должны работать эти структуры данных, для них нет "стандартного api".

Промисы в JS появился совсем недавно и нельзя не заметить насколько богаче и выразительнее стал язык.
Хотя это неполноценные промисы с точки зрения Fp. Реализацию промисов "здорового человека" можно рассмотреть на одном из митапов.

В мире ФП существует гораздо больше широко употребимых алгебраических типов данных и алгебраических структур, которые позволяют гибко и безопасно производить операции над данными.

Функтор, бифунктор, моноид, аппликатив, монада, Option, Maybe, Either, [RemoteData][remote-data] - названия этих алгебраических структур и типов данных несут в себе всю необходимую информацию чтобы понять как хранятся данные, какие есть способы их обработки.

Конечно же их реализаций нет в JS/TS, многие отсутствуют и в более продвинутых языках.  
Самое замечательное заключается в том, что самые употребимые реализованы в библиотеках.

- [ramda] - хэлперы в фп-стиле
- [fp-ts] - реализация алгебраических структур и типов данных в соответствии со спецификацией fantasy-land  
  На базе этой библиотеки развивается целая экосистема:
  - [io-ts] - валидация данных при помощи type-guards
  - [remote-data] - алгебраический тип данных для сетевых взаимодействий  

Библиотеки [ramda], [fp-ts], [io-ts] вошли в рейтинг [State of JS 2020](https://2020.stateofjs.com/ru-RU/other-tools/)

## Algebraic Data Types (ADT)
ADT — это универсальный тип данных. С помощью него можно представить большинство типов данных.
ADT называются алгебраическими, потому что их можно представить как некую алгебраическую композицию типов его составляющих.
Часто ADT называют контейнерными, т.к. для хранения данных в этих типах используются специальные структуры - контейнеры.

Все мы пользуемся контейнерными типами.
Рассмотрим Array и Promise.

```ts
const array = [1,2,3,4];
console.log({ array });
const arrayChanged = array.map(value => value + 1);
console.log({ arrayChanged });

const promise = Promise.resolve(1);
console.log({ promise });
const promiseChanged = promise.then(value => value + 1)
console.log({ promiseChanged });
```
Реализовать ADT (контейнерный тип данных) можно используя как ООП, так и ФП.
Обычно подразумевают, что для ADT должна быть реализована алгебра - т.е. обеспечено выполнение набора законов.
Алгебраические структуры - это типы данных, на которых реализована какая-то часть из набора законов ADT

[Зоопарк Алгебрaических Типов Данных](https://habr.com/ru/post/207126/)  
[Почему функциональное программирование такое сложное](https://habr.com/ru/post/505928/)

[Typescript]: https://www.typescriptlang.org/
[Reason]: https://reasonml.github.io/
[Elm]: https://elm-lang.org/
[Flow]: https://flow.org/

[ramda]: https://ramdajs.com/
[RxJS]: https://rxjs.dev/guide/overview

[fantasy-land]: https://github.com/fantasyland/fantasy-land
[fp-ts]: https://gcanti.github.io/fp-ts/
[io-ts]: ttps://gcanti.github.io/io-ts/
[swagger-codegen]: https://github.com/devexperts/swagger-codegen-ts
[remote-data]: https://github.com/devexperts/remote-data-ts
[Most]: https://github.com/mostjs/core

[dx-platform]: https://github.com/devexperts/dx-platform