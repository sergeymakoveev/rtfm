# Fp: Intro

## State of JavaScript 2020

[Награды](https://2020.stateofjs.com/ru-RU/awards/)
* самая используемая технология - [Typescript]
* наиболее интересная - [GraphQL]

[Технологии](https://2020.stateofjs.com/ru-RU/technologies/)
* безудержный рост [Typescript], его прямой конкурент [Flow] исчез с горизонта, остальные ([Reason], [Elm]) не существенны
* неудовлетворенность существующими state managers:
  - кривая популярности [Redux] повернула в обратную сторону
  - MobX в аналогичной ситуации
  - происходит отказ от state managers в пользу использования [React Context][ReactContext], [React Hooks][ReactHooks], других решений
* [GraphQL] в этом году обещает выйти в широкое использование проектами
* [GraphQL]-библиотеки ([Apollo], [Relay]) не пользуются особой популярностью - большинство использует собственные решения?

[Front-end Frameworks](https://2020.stateofjs.com/en-US/technologies/front-end-frameworks/)
* появилось много новых игроков, [Svelte] - фаворит
* тройка наиболее используемых не изменилась

[Data Layer](https://2020.stateofjs.com/ru-RU/technologies/datalayer/)
* [GraphQL] останется с нами навсегда, как и REST
* тройка [GraphQL]+[Relay]+[Apollo] без сомнений лидируют наравне с [Redux], который значительно сдал позиции относительно прошлого года
* мы неплохо ориентируемся в Redux-стеке, но пришла пора подбирать решения для GraphQL-стека

[Build tools](https://2020.stateofjs.com/ru-RU/technologies/build-tools/)
* много новых сборщиков, преследуют разные цели:
  - скорость ([esbuild])
  - замена смежных инструментов ([Rome])
  - интеграция со смежными инструментами ([Webpack])
  - zero configuration ([parsel], [esbuild])
* в качестве сборщика стал выступать tsc (typescript cli) - как следствие отказа от использования бандлеров
  в пользу поддержания набора скриптов для сборки
* из интересных - [Rome]):
  - Rome is a linter, compiler, bundler, and more for JavaScript, [TypeScript], JSON, HTML, Markdown, and CSS.
  - Rome is designed to replace Babel, ESLint, webpack, Prettier, Jest, and others.

[Tools](https://2020.stateofjs.com/ru-RU/other-tools/)
* в виду окончания развития MomentJS появились альтернативы
  - [date-fns](https://date-fns.org/)
  - [Day.js](https://day.js.org/)
  - [Luxon](https://moment.github.io/luxon) - преемник MomentJS
* держатся в списке underscore и lodash - как дань традиции
* присутствует [ramda] и [RxJS] - хороший знак, что идеи FP/RP находят своих поклонников
* ниже находим [fp-ts] и [io-ts], что подтверждает сказанное ранее о FP

Рост популярности Typescript и GraphQL не случаен:
* связка Typescript+GraphQL позволяет типизировать данные "последней мили" - решение сдерживающего фактора при внедрении TS
* отлично интегрирована с react
* при использовании GraphQL позволяет отказаться от Redux в пользу менее глобальных решений

Существует несколько решений для типизации данных, получаемых через сетевое соединение.  
Самые широкоиспользуемые - [GraphQL], [io-ts], есть собственные решения и комбинации вышеперечисленых.  
На Secon 2020 эта тема должна была раскрыться в серии из 3х докладов фронтенд-секции, планировалось проведение кркглого стола с привлечением дукладчиков из бекенд-секции 

## Опыт DX

Предметная область проектов - финансовые приложения для биржевой торговли.  
Исходя из требований предметной области практикуют функциональное реактивное программирование на TS со 100% покрытием типами.

Стэк:
- ts/ts-node, [Webpack], [RxJS], react, [io-ts], [swagger-codegen]
- adt, [fp-ts], [remote-data]

Квалифицированная команда платформы, платформа в опенсорсе: [dx-platform]  

Собственные опенсорс проекты:
* [remote-data]
* [swagger-codegen]

Участие в сторонних опенсорс проектах:  
* [fp-ts]

Техминутки - короткие и содержательные тематические live-coding митапы, в ходе которых тема разбирается на примерах.
Длительность варьируется, в среднем - около часа. Митап разбивается на сессии лайвкодинга по 15-20 минут, потом следует блок общения, где можно задать вопросы, выразить мнение, предложить свой подход.

## Немного истории

1930 — проблема разрешения (Entscheidungsproblem), Давид Гильберт  
1936 — теория машины Тьюринга, Алан Тьюринг  
1936 — лямбда-исчисление, Алонзо Чёрч (функциональный язык программирования, реализованый в виде алгебры, математически, пращур всех Фп-языков)  
1940e — Теория Категорий

**Модель вычислителя Тьюринга** - умозрительная абстракция.  
**Лямбда-исчисление** - раздел математической логики.

1957 — Fortran, Джон Бэкус  
1958 — Lisp, Джон Маккарти и Пол Грэм (FP)  
1970 — Scheme, Гай Стил и Джеральд Сассман (FP)  
1970 — Pascal, Николас Вирт  
1972 — C, Деннис Ритчи  
1973 — ML, Робин Милнер (теория типов Милнера, потомки OCaml, F#, RisenML)  
1980 — SmallTalk, Алан Кей (OOP)  
1983 — С++, Бьерн Страуструп (OOP)  
1990 — Haskell (FP)  
1991 — Python, Гвидо ван Россум (OOP, +FP)  
1996 — JavaScript (ECMAScript), Брэндон Айх (OOP, +FP)  
1996 — Java, Джеймс Гослинг (OOP, +FP)  
2003 — Scala, Мартин Одерски (FP, OOP)

Ссылки:  
[Краткая, неполная, и в основном неверная история языков программирования](https://habr.com/ru/post/165093/)  
[Краткая и на 146% точная история языков программирования](https://habr.com/ru/post/481822/)

Бесспорно что ООп в настоящее время значительно популярнее Фп.  
Почему?  
Математический базис/прототип высокоуровневого Фп-языка существовал уже в 1936г, в 1958 он воплотился в языке Lisp.  
Первый язык с ООп - SmallTalk, 1980г.  
Между Lisp и SmallTalk лежит 20 лет.  
Почему не стал популярен?

Наверняка причина кроется в сложности абстракций, которыми оперируют языки Фп.  
Гораздо нагляднее представить предметную область и бизнес-процессы в виде объектов, которые произвольно взаимодействуют друг с другом, нежели в виде композиции функций, которые обрабатывают потоки данных.

Современные высокоуровневые языки чаще всего являются мультипарадигменными - можно использовать как ООП, так и ФП, так и их сочетание.  
Конечно же есть и исключения - Haskel, Elm, Erlang, чаще Фп-языки отказываются от возможностей ООп, чем обратно.  
И наоборот, в языках ООп, стараются реализовать возможности для более удобного использования функциональных практик (lambda в Java, Promise в JavaScript)

## ООП и ФП

ООП: инкапсуляция, полиморфизм и наследование  
FP: алгебраические типы данных и функции высших порядков

OOП:
- предметная область представляется в виде объектов произвольной структуры
- для реализации бизнес-логики объекты произвольно взаимодействуют друг с другом
- много свободы - легко писать плохой код
- SOLID являются декларативными соглашениями для разумных ограничений этой свободы
- дизайн-паттерны для декларации популярных архитектурных решений на уровне соглашений

FP:
- предметная область и бизнес-логика выражаются в виде алгебраических типов данных и функций, отвечающих за композицию этих данных
- поставлены жесткие рамки - хороший код писать лекче, чем плохой
- алгебраические структуры и алгебраические типы данных (как унифицированные, так и пользовательские)
  четко декларируют их использование на уровне типов и кода 

Всем будет понятно как обработать данные, если речь идет о массиве или промисе, т.к. "у них стандартное, всем известное api" (если говорить иначе мы знаем алгебраические операции или алгебру, реализованную для этих алгебраических типов данных).  
Менее понятная ситуация если речь идет о стэке, очереди, потоке, дереве, графе, векторе, матрице - на уровне негласных соглашений (дизайн-паттернов) мы представляем как должны работать эти структуры данных, для них нет "стандартного api".

Промисы в JS появился совсем недавно и нельзя не заметить насколько богаче и выразительнее стал язык.
Хотя это неполноценные промисы с точки зрения Fp. Реализацию промисов "здорового человека" можно рассмотреть на одном из митапов.

В мире ФП существует гораздо больше широко употребимых алгебраических типов данных и алгебраических структур, которые позволяют гибко и безопасно производить операции над данными.

Функтор, бифунктор, моноид, аппликатив, монада, Option, Maybe, Either, [RemoteData][remote-data] - названия этих алгебраических структур и типов данных несут в себе всю необходимую информацию чтобы понять как хранятся данные, какие есть способы их обработки.

Конечно же их реализаций нет в JS/TS, многие отсутствуют и в более продвинутых языках.  
Самое замечательное заключается в том, что самые употребимые реализованы в библиотеках.

- [ramda] - хэлперы в фп-стиле
- [fp-ts] - реализация алгебраических структур и типов данных в соответствии со спецификацией fantasy-land  
  На базе этой библиотеки развивается целая экосистема:
  - [io-ts] - валидация данных при помощи type-guards
  - [remote-data] - алгебраический тип данных для сетевых взаимодействий  

Библиотеки [ramda], [fp-ts], [io-ts] вошли в рейтинг [State of JS 2020](https://2020.stateofjs.com/ru-RU/other-tools/)

## Algebraic Data Types (ADT)
ADT — это универсальный тип данных. С помощью него можно представить большинство типов данных.
ADT называются алгебраическими, потому что их можно представить как некую алгебраическую композицию типов его составляющих.
Часто ADT называют контейнерными, т.к. для хранения данных в этих типах используются контейнеры и данные выглядят как запакованные в коробку.

Все мы пользуемся контейнерными типами.
Рассмотрим Array и Promise.

```
const array = [1,2,3,4];
console.log({ array });
const arrayChanged = array.map(value => value + 1);
console.log({ arrayChanged });

const promise = Promise.resolve(1).then(value => )
console.log({ promise });
const promiseChanged = promise.then(value => value + 1)
console.log({ promiseChanged });
```
Реализовать контейнерный тип данных можно используя как ООП, так и ФП, многие это делали сами.
Реализовать ADT тоже можно используя как ООП, так и ФП, но ADT для ФП являются "нативными". 
Чтобы тип данных стал "алгебраическим" нужно реализовать на этом типе алгебру - т.е. обеспечить выполнение набора законов.
Алгебраические структуры - это типы данных, на которых реализована какая-то чать из набора законов ADT
ADT включает в себя набор алгебраических структур в соответствии с  

[Зоопарк Алгебрaических Типов Данных](https://habr.com/ru/post/207126/)  
[Почему функциональное программирование такое сложное](https://habr.com/ru/post/505928/)

[esbuild]: https://esbuild.github.io/
[Webpack]: https://webpack.js.org/
[Parsel]: https://parceljs.org/
[Rome]: https://rome.tools/

[GraphQL]: https://graphql.org/
[Apollo]: https://apollographql.com/client
[Relay]: https://relay.dev/
[Redux]: https://redux.js.org/
[ReactContext]: https://ru.reactjs.org/docs/context.html
[ReactHooks]: https://ru.reactjs.org/docs/hooks-reference.html

[Flow]: https://flow.org/

[Svelte]: https://svelte.dev/

[Typescript]: https://www.typescriptlang.org/
[Reason]: https://reasonml.github.io/
[Elm]: https://elm-lang.org/

[ramda]: https://ramdajs.com/
[RxJS]: https://rxjs.dev/guide/overview

[fantasy-land]: https://github.com/fantasyland/fantasy-land
[fp-ts]: https://gcanti.github.io/fp-ts/
[io-ts]: ttps://gcanti.github.io/io-ts/
[swagger-codegen]: https://github.com/devexperts/swagger-codegen-ts
[remote-data]: https://github.com/devexperts/remote-data-ts

[dx-platform]: https://github.com/devexperts/dx-platform